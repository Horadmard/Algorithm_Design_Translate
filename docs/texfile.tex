% !TEX TS-program = xelatex
% !TEX encoding = UTF-8

% This is a simple template for a XeLaTeX document using the "article" class,
% with the fontspec package to easily select fonts.

\documentclass{book} % use larger type; default would be 10pt
\usepackage{tikz}
\usepackage{graphicx}
\graphicspath{ {./figures/} }
\usepackage{xepersian} 

\settextfont{Yas}
\setlatintextfont{Bitstream Charter}
\setdigitfont{Yas}

\begin{document}


\title{طراحی الگوریتم: پیشرفتهای روشمند}
\author{حسین رادمرد}

%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\maketitle

\section{مسئله 83 رنگ کردن یک گراف دو رنگی}

در این مسئله، مانند موارد بعدی، حل مسئله هدف ماست و بهینه بودن جواب برای ما حائز اهمیت نیست. دراینجا، ما الگوریتمی را برای رنگ کردن گراف با دردست داشتن تنها دو رنگ، بررسی میکنیم. نسخه‌ی کلی‌تر(رنگ آمیزی با هر تعداد رنگ) در مسئله‌ی 59، صفحه‌ی 236 بررسی میشود. گرچه، نسخه‌ی فعلی بسیار بهینه‌تر است. در ادامه، این بحث بسیار به موضوع "گرافهای پرکاربرد: گراف‌های دوبخشی" مرتبط است.

گراف همبند بدون جهت 
{G = N, V)}\lr
 (ناتهی) به ما داده شده‌ست. ما قصد داریم با رنگ‌های سیاه و سفید گراف را رنگ آمیزی کنیم به گونه‌ای که هیچ دو راس همسایه‌ای دارای رنگ یکسانی نباشند. چنین گرافی را گراف دورنگی مینامیم. الگوریتم حریصانه ای که ما قصد ساخت آن را برای این منظور داریم به پیمایش سطری گراف ها مرتبط است که آن را در ابتدا بررسی کردیم.


 چنین گرافی را گراف دورنگی مینامیم. الگوریتم حریصانه ای که ما قصد ساخت آن را برای این منظور داریم به پیمایش سطری گراف ها مرتبط است که آن را در ابتدا بررسی کردیم.
\subsection*{پیمایش سطری گراف: یادآوری}
\subsubsection*{معرفی}

اول از همه، اجازه دهید مفاهیم "فاصله‌ی میان دو راس" و "پیمایش سطری" را برای گراف‌های همبندِ بدون جهت تعریف کنیم.

تعریف 10 (فاصله‌ی میان دو راس):
در نظر میگیریم، G = (N, V) یک گراف همبند بدون جهت و s و s' دو راس این گراف باشند. طول کوتاه‌ترین مسیر میان s و s' را فاصله‌ی میان s و s' گویند.


تعریف 11 (جستجوی سطری):
فرض کنیم G یک گراف همبند و بدون جهت و s یکی از راس های آن باشد. هر فرایندی که با افزایش فاصله‌ها از راس s با راس های گراف G برخورد میکند به عنوان پیمایش سطری گراف G از s شناخته میشود.  



از نمودار (b) در شکل 7.8 صفحه‌ی 363، میتوانیم نتیجه بگیریم که لیست ⟨a, b, c, d, e, f, g, h⟩ با پیمایش سطری با شروع از راس a مطابقت دارد. و همین مطلب برای لیست ⟨a, c, b, d, e, h, f, g⟩ نیز صدق میکند.

% \begin{latin}
    
%     \begin{tikzpicture}
%         [scale=.8,auto=left,every node/.style={circle,fill=blue!20}]
%         \node (n1) at (1,1) {a};
%         \node (n2) at (4,8)  {b};
%         \node (n3) at (8,9)  {c};
%         \node (n4) at (11,8) {d};
%         \node (n5) at (9,6)  {e};
%         \node (n6) at (5,5)  {f};
%         \node (n7) at (5,10)  {g};
  
%     \foreach \from/\to in {n6/n4,n4/n5,n5/n1,n1/n2,n2/n5,n2/n3,n3/n4}
%     \draw (\from) -- (\to);
  
% \end{tikzpicture}

% \end{latin}

\includegraphics{f1.pdf}

تصویر 7.8 - یک مثال از گراف. تصویر (a) گرافی را نمایش میدهد که مثالی از حالت مسئله را نشان میدهد.  تصویر (b) کوتاه‌ترین مسیر راس a را تا هر راس گراف با خطوط پررنگ نشان میدهد. در تصویر (b)، عددی که در هر راس مشخص است در واقع فاصله‌ی آن راس تا راس a است.



%\subsection{}
\newpage
\subsubsection*{حلقه بدون تغییر}

ما علاقه داریم یک الگوریتم بدون تغییر بسازیم؛ یک الگوریتم حریصانه؛ و اینگونه خود را محدود میکنیم. برای جستجوی حلقه بدون تغییر، ادامه ی این ساز و کار به خواننده واگذار میشود. اکنون تصور میکنیم قسمتی از کار انجام شده ست(بخش ۳، صفحه ۹۳ را ببنید). به این ترتیب، برای یک گراف جزئی G′ = (N′, V′) (زیرگراف G القا شده با مجموعه رئوس 'N، شامل رئوس ابتدایی)، لیستی تشکیل شده از پیمایش سطری 'G با شروع از s داریم.
عموما* این لیست، CLOSE نامیده میشود. پیشرفت این روند شامل گستردن این لیست با افزودن رئوسی است که در CLOSE نیستند و تا جای ممکن به s نزدیکند.


از آنجایی که هر راسی که در CLOSE حضور نداشته باشد، یک کاندید احتمالی برای انقال به CLOSE است، در غیاب بقیه ی مفروضات، پیشرفت ممکن اما به همان نسبت هزینه بر است.
پیشنهاد میکنیم که نسخه اول این ثابت را با اضافه کردن یک ساختمان داده بهبود ببخشید. ساختمان داده OPEN شامل تمام رئوسی ست که در CLOSE حضور نداشته و کاندید این موضوع هستند که همسایه حذاقل یکی از رئوس CLOSE هستند.
بیشین*، OPEN به عنوان یک لیست اولویت با مدیریت برروی فاصله ی عناصرش از ‌s بوجود می آید، این موضوع به این دلیل است که عنصری که باید به لیست CLOSE منتقل شود باید نزدیک ترین به s باشد.


بعدها میبینیم که نسخه ساده شده یک لیست اولویت نیز امکان پذیر است. برای ماندگاری این نسخه جدید از ثابت*، بهینه است که سر OPEN را به انتهای لیست CLOSE منتقل کنیم، و - به عنوان همتای تقویت ثابت** - برای معرفی همسایگان "جدید" عنصر منتقل شده به OPEN، عنصرهایی که نه در OPEN نه در CLOSE هستند(این یک انتخاب حریصانه است).

با این حال، با توجه به عنصری e در OPEN، پرسیدن مستقیم درباره وجود یا عدم وجود یکی از همسایگان آن در OPEN یا CLOSE می تواند پرهزینه باشد. راه حل بهتر شامل تقویت (جدید) با گزاره زیر است: از نظر رنگ آمیزی آینده، یک "رنگ" به هر راس گراف اختصاص می یابد، سفید اگر راس در OPEN یا CLOSE باشد، و در غیر این صورت خاکستری (در واقع، در اینجا، دو رنگ نقش مقادیر بولین را بازی می کنند). به شرطی که دسترسی مستقیم به رئوس امکان پذیر باشد، به روز رسانی OPEN آسان تر می شود. در پیشرفت، حفظ این مکمل ناوردا با رنگ آمیزی هر راسی که به OPEN منتقل می شود به رنگ سفید حاصل می شود.

بیایید به استراتژی مدیریت صف OPEN بازگردیم. آیا می توان به جای صف اولویت دار از یک صف ساده FIFO (نگاه کنید به بخش 1.8، صفحه 32) استفاده کرد؟ در این صورت، مدیریت OPEN به طور قابل توجهی ساده می شود. برای انجام این کار، زمانی که رأس e از OPEN خارج می شود تا به CLOSE ملحق شود، همسایگان e که نامزد ورود به OPEN هستند باید فاصله ای بیشتر یا مساوی با تمام عناصر موجود در OPEN داشته باشند، که این امر امکان داشتن یک صف مرتب را فراهم می کند. این بدان معناست که اگر e در فاصله k از s باشد، سایر عناصر OPEN در فاصله k یا (k + 1) از s قرار دارند، زیرا همسایگان "خاکستری" e در فاصله (k + 1) از s قرار دارند. این فرض را به ناوردا اضافه می کنیم. خواننده دعوت می شود بررسی کند که آیا این موضوع با راه‌اندازی حلقه واقعاً برقرار شده است. همچنان باید ثابت کرد که با پیشرفت حفظ می شود. در نهایت، ما ناوردای زیر را پیشنهاد می کنیم که از چهار بند تشکیل شده است.

\begin{enumerate}
    \item  بسته (CLOSE) یک صف اول-وارد-اول-خارج (FIFO) است که محتوای آن نشان دهنده یک "پیمایش عمق-اول" از زیرگراف G است که توسط رئوس موجود در بسته (CLOSE) تشکیل شده است.
    
    \item  باز (OPEN) یک صف اول-وارد-اول-خارج (FIFO) از رئوس همسایه رئوس موجود در بسته (CLOSE) است. اشتراک مجموعه بین باز (OPEN) و بسته (CLOSE) تهی است.

    \item اگر ابتدای صف باز (OPEN) حاوی رئوس با فاصله k از s باشد، سایر عناصر صف باز (OPEN) در فاصله k یا (k + 1) از s قرار دارند.

    \item در گراف G، رئوس موجود در بسته (CLOSE) یا باز (OPEN) به رنگ سفید رنگ آمیزی می شوند، سایر رئوس خاکستری هستند.
\end{enumerate}
\newpage

شکل ۷.۹، صفحه ۳۶۶، مراحل مختلف «پیمایش پهنای-اول» گراف شکل ۷.۸، صفحه ۳۶۳ را نشان می‌دهد. در هر گراف شکل، رئوس موجود در بسته (CLOSE) با خطوط خاکستری و رئوس موجود در باز (OPEN) با خطوط دوتایی نمایش داده شده‌اند. فواصل فقط به عنوان یادآوری ذکر شده‌اند، الگوریتم از آنها استفاده نمی‌کند. بیایید به عنوان مثال در مورد مرحله‌ای که منجر به گذار از شکل (e) به شکل (f) می‌شود، توضیح دهیم. در شکل (e)، بسته (CLOSE) لیست «پیمایش پهنای-اول» زیرگراف القا شده توسط رئوس a، b، c و d را در خود جای داده است. راس e، سر صف باز (OPEN)، به انتهای بسته (CLOSE) منتقل خواهد شد. کدام همسایه‌های e قرار است به OPEN ملحق شوند؟ c و b قبلاً در بسته (CLOSE) هستند، بنابراین موردی برای اضافه شدن ندارند. g  قبلاً در  باز (OPEN) است، تحت تأثیر قرار نمی‌گیرد. تنها راس باقی‌مانده h است که به صف باز (OPEN) ملحق شده و به رنگ سفید رنگ‌آمیزی می‌شود.

\subsubsection*{ساختارهای داده}

از دو نوع ساختار داده در این الگوریتم استفاده می‌شود. مورد اول، صف‌های اول-وارد-اول-خارج (FIFO)، در صفحه ۳۲ توضیح داده شده‌اند. مورد دوم مربوط به نسخه‌ی «رنگ‌آمیزی‌شده» گراف‌ها است.
گراف بدون جهت رنگ‌آمیزی‌شده (Undirected Colored Graph)

در این الگوریتم، نیاز به رنگ‌آمیزی رئوس‌های یک گراف، دسترسی به رنگ آن‌ها و کاوش لیست همسایگان وجود دارد، بنابراین تعاریف زیر ارائه می‌شود (فرض بر این است که مجموعه رنگ‌ها (Colors) تعریف شده است):

\begin{itemize}
    \item عملگر رنگ‌آمیزی‌ ColorGr(G, s, col): عملیاتی که رأس s گراف G را با رنگ col رنگ‌آمیزی می‌کند.
   
    \item تابع رنگ‌رأس‌ WhichColorGr(G, s) نتیجه نوع رنگ‌ها (Colors): تابعی که رنگ رأس s گراف G را برمی‌گرداند.
   
    \item عملگر همسایگان باز OpenNeighborsGr(G, s): عملیاتی که کاوش لیست همسایگان رأس s گراف G را آغاز می‌کند.
   
    \item تابع پایان لیست همسایگان‌ EndListNeighborsGr(G, s) نتیجه بولی (B): تابعی که مقدار درست (true) را برمی‌گرداند در صورتی که کاوش لیست همسایگان رأس s گراف G تمام شده باشد و در غیر اینصورت مقدار نادرست (false) را برمی‌گرداند.
   
    \item عملگر خواندن همسایگان‌ ReadNeighborsGr(G, s, s′): عملیاتی که هویت رأس "زیر خواننده" لیست همسایگان s را در s′ ذخیره کرده و سپس خواننده را یک موقعیت به جلو حرکت می‌دهد.

\end{itemize}

در این کاربرد، از نظر بیان الگوریتم و کارایی، بهترین بهینه‌سازی نمایش آن با استفاده از لیست همجوری است (برای مشاهده‌ی نمونه‌ای از چنین نمایشی برای گراف‌های جهت‌دار، به شکل (d) در صفحه‌ی ۲۳ مراجعه کنید). بنابراین، گراف به صورت یک "سه‌تایی" (G = (N, V, R)) تعریف می‌شود که در آن R نشان‌دهنده رنگ‌ها است (در حال حاضر "سفید" و "خاکستری").

\subsubsection*{الگوریتم}

علاوه بر نمودار G، این الگوریتم از متغیرهای cv راس جاری و فهرست همسایگان برای مرور لیست همسایگان استفاده می کند.

\begin{latin}
    
    \begin{enumerate}
        
        \item constants
        \item n ∈ N1 and n = . . . and N = 1 .. n and Colors = {grey, white} and
        \item V ∈ N × N and V = {. . .}
        \item variables
        \item R ∈ N → Colors and G = (N, V, R) and
        \item s ∈ N and cv ∈ N and neighb ∈ N and CLOSE ∈ FIFO(N) and OPEN ∈ FIFO(N)
        \item begin
        
        
    \end{enumerate}
    
\end{latin}

\end{document}
